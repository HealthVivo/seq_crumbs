#!/usr/bin/env python

# Copyright 2012 Jose Blanca, Peio Ziarsolo, COMAV-Univ. Politecnica Valencia
# This file is part of seq_crumbs.
# seq_crumbs is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

# seq_crumbs is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR  PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with seq_crumbs. If not, see <http://www.gnu.org/licenses/>.

import sys
import argparse

from crumbs.utils import (main, STDIN, STDOUT, get_inputs_from_args,
                                INFILES, OUTFILE)
from crumbs.seqio import guess_format, seqio
from crumbs.exceptions import TooManyFiles, WrongFormatError


SUPPORTED_FORMATS = ['fasta', 'fastq', 'fastq-illumina']


def _setup_argparse():
    'It prepares the command line argument parsing.'
    description = 'Get first seqs from file[s]'
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument(INFILES, default=STDIN, nargs='*',
                        help="Sequence input file to process")
    parser.add_argument('-o', '--outfile', default=STDOUT, dest=OUTFILE,
                        nargs='*', help="Sequence output file to process")
    parser.add_argument('-f', '--format', dest='format', help='Output format',
                        required=True, choices=SUPPORTED_FORMATS)

    return parser


def _parse_args(parser):
    '''It parses the command line and it returns a dict with the arguments.'''
    parsed_args = parser.parse_args()

    in_fhands = get_inputs_from_args(parsed_args)
    if len(in_fhands) == 2:
        # 2 for fasta + qual and 1 for everything else
        formats = [guess_format(fhand) for fhand in in_fhands]
        if formats != ('fasta', 'qual'):
            msg = 'Wrong input file formats, the first one should be fasta'
            msg += ' and the second qual.'
            WrongFormatError(msg)
    elif len(in_fhands) > 2:
        msg = 'This command accepts, 0 input files (stdin), 2 files (fasta + '
        msg += 'qual) or 1 file (all other input formats, %s were given.'
        msg %= str(len(in_fhands))
        raise TooManyFiles(msg)

    fmt = parsed_args.format

    # output fhands
    out_fpaths = getattr(parsed_args, OUTFILE)
    if out_fpaths == STDOUT:
        out_fhands = [sys.stdout]
    else:
        out_fhands = [open(out_fpath, 'w') for out_fpath in out_fpaths]
    if len(out_fhands) > 2:
        msg = 'This command accepts, 0 output files (stout), 2 files (fasta + '
        msg += 'qual) or 1 file (all other output formats, %s were given.'
        msg %= str(len(in_fhands))
        raise TooManyFiles(msg)
    elif len(out_fhands) == 2 and fmt != 'fasta':
        msg = 'With 2 ouput files, the output format should be fasta '
        msg += '(and qual)'
        raise WrongFormatError(msg)

    return {'out_fhands': out_fhands, 'in_fhands': in_fhands,
            'format': fmt}


def main_seqio():
    'The main function of the seqio binary'
    parser = _setup_argparse()
    args = _parse_args(parser)

    in_fhands = args['in_fhands']
    out_fhands = args['out_fhands']
    out_format = args['format']

    seqio(in_fhands, out_fhands, out_format)


if __name__ == '__main__':
    sys.exit(main(main_seqio))
